                                                        截取别人的笔记(对错未知)

参数解析
1.just(T...): 将传入一个或多个参数依次发送出来:Observable.just("a", "b", "c");

2.from(T[]) / from(Iterable<? extends T>) : 将传入的数组或 Iterable 拆分成具体对象后，依次发送出来。String[] words = {"a", "b", "c"};Observable observable = Observable.from(words);

3.Func1:  Func1 和 Action 的区别在于， Func1 包装的是有返回值的方法。另外，和 ActionX 一样， FuncX 也有多个，用于不同参数个数的方法。FuncX 和 ActionX 的区别在 FuncX 包装的是有返回值的方法。

4.map():转换功能通过FunCX(x,y) 方法将参数中的 String 对象转换成一个 Bitmap 对象后返回，而在经过 map() 方法后，事件的参数类型也由 String 转为了 Bitmap。

5.flatMap():和map()有点像just和from的关系.

6.lift():(可用用来封装4，5-但不建议使用)在 Observable 执行了 lift(Operator) 方法之后，会返回一个新的 Observable，这个新的 Observable 会像一个代理一样，负责接收原始的 Observable 发出的事件，并在处理后发送给 Subscriber.

7.filter():过滤不用的，筛选

8.take(3):取前三条 takeLast(3)：后三个

9.timeout()超时出错


10.  (1).自动创建 Subscriber ，并使用 onNextAction 来定义 onNext()    observable.subscribe(onNextAction);
    (2).自动创建 Subscriber ，并使用 onNextAction 和 onErrorAction 来定义 onNext() 和 onError()  observable.subscribe(onNextAction, onErrorAction);
    (3).自动创建 Subscriber ，并使用 onNextAction、 onErrorAction 和 onCompletedAction 来定义 onNext()、 onError() 和 onCompleted()
            observable.subscribe(onNextAction, onErrorAction, onCompletedAction);

11.Scheduler:调度器
    (0).subscribeOn():Observable.OnSubscribe 被激活时所处的线程。    事件产生的线程
    (0).observeOn():指定 Subscriber 所运行在的线程                   消费的线程
    (1).Schedulers.immediate(): 直接在当前线程运行，相当于不指定线程。这是默认的 Scheduler.
    (2).Schedulers.newThread(): 总是启用新线程，并在新线程执行操作.
    (3).Schedulers.io(): I/O 操作（读写文件、读写数据库、网络信息交互等）所使用的 Scheduler。行为模式和 newThread() 差不多，区别在于 io() 的内部实现是是用一个无数量上限的线程池，可以重用空闲的线程，
            因此多数情况下 io() 比 newThread() 更有效率。不要把计算工作放在 io() 中，可以避免创建不必要的线程
    (4).Schedulers.computation(): 计算所使用的 Scheduler。这个计算指的是 CPU 密集型计算，即不会被 I/O 等操作限制性能的操作，例如图形的计算。这个 Scheduler 使用的固定的线程池，大小为 CPU 核数。
            不要把 I/O 操作放在 computation() 中，否则 I/O 操作的等待时间会浪费 CPU
    (5).Android 还有一个专用的 AndroidSchedulers.mainThread()，它指定的操作将在 Android 主线程运行。
    (6)observeOn() 指定的是它之后的操作所在的线程。因此如果有多次切换线程的需求，只要在每个想要切换线程的位置调用一次 observeOn() 即可.
    (7)subscribeOn()不同于 observeOn(),subscribeOn() 的位置放在哪里都可以，但它是只能调用一次的.
    (8)Observable.doOnSubscribe():它和 Subscriber.onStart() 同样是在 subscribe() 调用后而且在事件发送前执行，但区别在于它可以指定线程.



一.SecondActivity里的笔记

1.一个Observable可以发出零个或者多个事件，知道结束或者出错。每发出一个事件，就会调用它Subscriber的onNext方法，最后调用Subscriber.onNext()或者Subscriber.onError()结束。

2.Rxjava的看起来很想设计模式中的观察者模式，但是有一点明显不同，那就是如果一个Observerble没有任何的的Subscriber，那么这个Observable是不会发出任何事件的

3.onStart(): 这是 Subscriber 增加的方法。它会在 subscribe 刚开始，而事件还未发送之前被调用，可以用于做一些准备工作，例如数据的清零或重置。
    这是一个可选方法，默认情况下它的实现为空。需要注意的是，如果对准备工作的线程有要求（例如弹出一个显示进度的对话框，这必须在主线程执行）， onStart() 就不适用了

4.在不指定线程的情况下， RxJava 遵循的是线程不变的原则，即：在哪个线程调用 subscribe()，就在哪个线程生产事件；在哪个线程生产事件，就在哪个线程消费事件。如果需要切换线程，就需要用到 Scheduler （调度器）。


                                                                    RxBus
1.Subject:在 RxJava 里有一个对象 Subject，既是 Observable 又是 Observer，可以把 Subject 理解成一个管道或者转发器，数据从一端输入，然后从另一端输出.
        Subject 有好几种，这里可以使用最简单的 PublishSubject。一旦数据从一端传入，结果会里立刻从另一端输出.
        PublishSubject只有被订阅后才会把接收到的事件立刻发送给订阅者.

2.volitale:同步 http://blog.csdn.net/yueliangniao1/article/details/7227795


